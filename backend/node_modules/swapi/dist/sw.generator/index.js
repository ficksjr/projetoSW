"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const storage_1 = require("../storage");
const types_1 = require("../types");
const path_1 = require("path");
const lodash_1 = require("lodash");
const json2yaml_1 = require("json2yaml");
const helpers_1 = require("../helpers");
function generateSwaggerJson() {
    const storageInstance = storage_1.NodeStorage.getInstance();
    const packageJson = getPackageJson();
    const swaggerJson = generateSwaggerJsonBody(packageJson);
    storageInstance.nodes
        .filter((node) => !node.isAbstract)
        .forEach((node) => {
        const fullPath = storageInstance.getNodeFullPath(node.name);
        node.endpoints.forEach((endpoint) => {
            const fullEndpointPath = helpers_1.urlResolve(fullPath, endpoint.path);
            const path = convertToSwaggerUrl(fullEndpointPath);
            storageInstance.setUrlParamFromFullPath(node.name, endpoint.name);
            const method = generateSwaggerJsonMethod(node, endpoint);
            if (swaggerJson.paths.hasOwnProperty(path)) {
                swaggerJson.paths[path][endpoint.method] = method;
            }
            else {
                swaggerJson.paths[path] = {
                    [endpoint.method]: method
                };
            }
        });
    });
    storageInstance.types.forEach((type) => {
        const definitions = generateSwaggerJsonDefinitionType(type);
        swaggerJson.definitions[type.name] = definitions;
    });
    return swaggerJson;
}
exports.generateSwaggerJson = generateSwaggerJson;
function generateSwaggerYaml() {
    const swJson = generateSwaggerJson();
    return swaggerJsonToYaml(swJson);
}
exports.generateSwaggerYaml = generateSwaggerYaml;
function getPackageJson() {
    const packageJson = require(path_1.resolve(process.cwd(), 'package.json'));
    packageJson.swapi = packageJson.swapi || {};
    return packageJson;
}
function generateSwaggerJsonBody(packageJson) {
    return {
        swagger: '2.0',
        info: {
            version: packageJson.version,
            title: packageJson.name,
            description: packageJson.description,
            license: {
                name: packageJson.license
            },
            contact: {
                name: packageJson.author
            }
        },
        host: packageJson.swapi.host,
        basePath: packageJson.swapi.basePath,
        schemes: packageJson.swapi.schemes,
        produces: packageJson.swapi.produces,
        consumes: packageJson.swapi.consumes,
        paths: {},
        definitions: {}
    };
}
function generateSwaggerJsonMethod(node, endpoint) {
    const packageJson = getPackageJson();
    const method = {
        description: endpoint.description,
        operationId: lodash_1.camelCase(`${node.name} ${endpoint.name}`),
        produces: packageJson.swapi.produces,
        responses: endpoint.responses.length ? {} : getDefaultResponseWithStatus(endpoint.method)
    };
    const parameters = prepareSwaggerMethodParams(endpoint, endpoint.name);
    if (parameters.length) {
        method.parameters = parameters;
    }
    endpoint.responses.forEach((res) => {
        method.responses[res.status] = prepareSwaggerMethodResponse(res);
    });
    return method;
}
function prepareSwaggerMethodParams(endpoint, operationId) {
    const urlParams = endpoint.urlParams.map((param) => prepareInUrlParam(param, types_1.ParameterLocation.UrlPath));
    const queryParams = endpoint.query.map((param) => prepareInUrlParam(param, types_1.ParameterLocation.Query));
    const headerParams = endpoint.header.map((param) => prepareInUrlParam(param, types_1.ParameterLocation.Header));
    const parameters = lodash_1.concat(queryParams, urlParams, headerParams);
    if (endpoint.body.length > 0 || !!endpoint.bodyType) {
        const bodyParams = prepareSwaggerMethodBodyParameter(endpoint, operationId);
        return lodash_1.concat(parameters, bodyParams);
    }
    return parameters;
}
function prepareInUrlParam(param, location) {
    const preparedParam = {
        name: param.name,
        in: location,
        description: param.description,
        required: param.required,
    };
    if (param.isArray) {
        preparedParam.type = types_1.Types.Array;
        if (helpers_1.isReference(param.type)) {
            preparedParam.items = {
                $ref: param.type
            };
        }
        else {
            preparedParam.items = {
                type: param.type
            };
        }
    }
    else {
        preparedParam.type = param.type;
    }
    return preparedParam;
}
function prepareSwaggerMethodBodyParameter(endpoint, operationId) {
    const bodyParam = {
        name: `${operationId}Body`,
        in: types_1.ParameterLocation.Body,
        schema: {}
    };
    if (endpoint.bodyType === types_1.Types.Number || endpoint.bodyType === types_1.Types.String) {
        if (endpoint.bodyIsArray) {
            bodyParam.schema.type = types_1.Types.Array;
            bodyParam.schema.items = { type: endpoint.bodyType };
        }
        else {
            bodyParam.schema.type = endpoint.bodyType;
        }
        return bodyParam;
    }
    if (helpers_1.isReference(endpoint.bodyType)) {
        const ref = createSwaggerReference(endpoint.bodyType);
        if (endpoint.bodyIsArray) {
            bodyParam.schema.type = types_1.Types.Array;
            bodyParam.schema.items = { $ref: ref };
        }
        else {
            bodyParam.schema.$ref = ref;
        }
        return bodyParam;
    }
    const properties = {};
    const required = endpoint.body
        .filter((param) => param.required)
        .map((param) => param.name);
    if (required.length) {
        bodyParam.schema.required = required;
    }
    endpoint.body.forEach((param) => {
        const schema = {};
        if (param.isArray) {
            schema.type = types_1.Types.Array;
            if (helpers_1.isReference(param.type)) {
                const ref = createSwaggerReference(param.type);
                schema.items = { $ref: ref };
            }
            else {
                schema.items = { type: param.type };
            }
        }
        else {
            if (helpers_1.isReference(param.type)) {
                schema.$ref = createSwaggerReference(param.type);
            }
            else {
                schema.type = param.type;
            }
        }
        properties[param.name] = schema;
    });
    if (endpoint.bodyIsArray) {
        bodyParam.schema.type = types_1.Types.Array;
        bodyParam.schema.items = {
            type: types_1.Types.Object,
            properties
        };
    }
    else {
        bodyParam.schema.type = types_1.Types.Object;
        bodyParam.schema.properties = properties;
    }
    return bodyParam;
}
function prepareSwaggerMethodResponse(res) {
    const schema = {};
    if (helpers_1.isReference(res.responseType)) {
        const reference = createSwaggerReference(res.responseType);
        if (res.isArray) {
            schema.type = types_1.Types.Array;
            schema.items = { $ref: reference };
        }
        else {
            schema.$ref = reference;
        }
    }
    else {
        if (res.isArray) {
            schema.type = types_1.Types.Array;
            schema.items = { type: res.responseType };
        }
        else {
            schema.type = res.responseType;
        }
    }
    return {
        description: res.description,
        schema
    };
}
function getDefaultResponseWithStatus(method) {
    let status;
    if (method === types_1.HttpMethods.GET) {
        status = '200';
    }
    else if (method === types_1.HttpMethods.POST) {
        status = '201';
    }
    else if (method === types_1.HttpMethods.PUT || method === types_1.HttpMethods.PATCH || types_1.HttpMethods.DELETE) {
        status = '204';
    }
    return {
        [status]: {
            description: 'OK',
            schema: { type: 'string' }
        }
    };
}
function generateSwaggerJsonDefinitionType(res) {
    const definition = {
        type: res.type
    };
    const properties = res.scheme.reduce((props, prop) => {
        if (prop.isArray) {
            props[prop.name] = { type: types_1.Types.Array };
            if (helpers_1.isReference(prop.type)) {
                props[prop.name].items = {
                    $ref: createSwaggerReference(prop.type)
                };
            }
            else {
                props[prop.name].items = {
                    type: prop.type
                };
            }
        }
        else {
            if (helpers_1.isReference(prop.type)) {
                props[prop.name] = {
                    $ref: createSwaggerReference(prop.type)
                };
            }
            else {
                props[prop.name] = {
                    type: prop.type
                };
            }
        }
        return props;
    }, {});
    if (res.type === types_1.Types.Array) {
        definition.items = { properties };
    }
    else {
        definition.properties = properties;
    }
    return definition;
}
function convertToSwaggerUrl(url) {
    return url.replace(/:[a-zA-Z]*/g, '$${$&}').replace(/:/g, '');
}
function createSwaggerReference(type) {
    return type.replace('#/', '#/definitions/');
}
function swaggerJsonToYaml(swJson) {
    return json2yaml_1.stringify(swJson);
}
//# sourceMappingURL=../../src/dist/sw.generator/index.js.map