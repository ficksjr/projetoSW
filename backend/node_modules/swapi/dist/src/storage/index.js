Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../types");
const lodash_1 = require("lodash");
const helpers_1 = require("../helpers");
class NodeStorage {
    constructor() {
        this._nodes = [];
        this._types = [];
    }
    get nodes() {
        return this._nodes;
    }
    get types() {
        return this._types;
    }
    static getInstance() {
        NodeStorage.instance = NodeStorage.instance || new NodeStorage();
        return NodeStorage.instance;
    }
    addNode(node) {
        if (node.relatedTo) {
            const relatedNode = this.findNodeByName(node.relatedTo);
            if (!relatedNode) {
                this.createNode(node.relatedTo, null);
            }
        }
        this._nodes.push(node);
    }
    createNode(name, path, relatedTo = null, endpoints = [], combiner = null) {
        const node = {
            name,
            path,
            relatedTo,
            endpoints,
            combiner
        };
        this.addNode(node);
        return node;
    }
    upsertNode(node) {
        const storedNode = this.findOrCreateNodeByName(node.name);
        if (node.endpoints) {
            node.endpoints.forEach((endpoint) => {
                this.upsertEndpoint(node.name, endpoint.name, endpoint);
            });
        }
        storedNode.name = node.name ? node.name : storedNode.name;
        storedNode.path = node.path ? node.path : storedNode.path;
        storedNode.relatedTo = node.relatedTo ? node.relatedTo : storedNode.relatedTo;
        storedNode.combiner = node.combiner ? node.combiner : storedNode.combiner;
        storedNode.isAbstract = node.isAbstract ? node.isAbstract : storedNode.isAbstract;
    }
    addEndpoint(nodeName, endpoint) {
        const node = this.findOrCreateNodeByName(nodeName);
        node.endpoints.push(endpoint);
    }
    createEndpoint(nodeName, name, path, method, description = '') {
        const endpoint = {
            name,
            path,
            method,
            description,
            body: [],
            urlParams: [],
            query: [],
            responses: [],
            bodyType: null,
            bodyIsArray: false
        };
        this.addEndpoint(nodeName, endpoint);
        return endpoint;
    }
    upsertEndpoint(nodeName, endpointName, endpoint) {
        const storedEndpoint = this.findOrCreateEndpointByName(nodeName, endpointName);
        storedEndpoint.description = endpoint.description || storedEndpoint.description;
        storedEndpoint.method = endpoint.method || storedEndpoint.method;
        storedEndpoint.name = endpoint.name || storedEndpoint.name;
        storedEndpoint.path = endpoint.path || storedEndpoint.path;
        if (endpoint.hasOwnProperty('urlParams')) {
            Object.entries(endpoint.urlParams).forEach(([, param]) => {
                const storedParam = this.findParameterByLocationAndName(nodeName, endpoint.name, types_1.ParameterLocation.UrlPath, param.name);
                if (storedParam && storedParam.type !== 'string' && param.type === 'string') {
                    return;
                }
                this.upsertUrlParam(nodeName, endpointName, param);
            });
        }
        if (endpoint.hasOwnProperty('query')) {
            Object.entries(endpoint.query).forEach(([, param]) => {
                const storedParam = this.findParameterByLocationAndName(nodeName, endpoint.name, types_1.ParameterLocation.Query, param.name);
                if (storedParam && storedParam.type !== 'string' && param.type === 'string') {
                    return;
                }
                this.upsertQueryParam(nodeName, endpointName, param);
            });
        }
        if (endpoint.hasOwnProperty('body')) {
            Object.entries(endpoint.body).forEach(([, param]) => {
                const storedParam = this.findParameterByLocationAndName(nodeName, endpoint.name, types_1.ParameterLocation.Body, param.name);
                if (storedParam && storedParam.type !== 'string' && param.type === 'string') {
                    return;
                }
                this.upsertBodyParam(nodeName, endpointName, param);
            });
        }
        if (endpoint.hasOwnProperty('response')) {
            endpoint.responses.forEach((response) => {
                this.upsertResponse(nodeName, endpoint.name, response.status, response);
            });
        }
    }
    complementEndpoint(nodeName, endpointName, endpoint) {
        const storedEndpoint = this.findOrCreateEndpointByName(nodeName, endpointName);
        storedEndpoint.description = storedEndpoint.description || endpoint.description;
        storedEndpoint.method = storedEndpoint.method || endpoint.method;
        storedEndpoint.name = storedEndpoint.name || endpoint.name;
        storedEndpoint.path = storedEndpoint.path || endpoint.path;
        if (endpoint.hasOwnProperty('urlParams')) {
            Object.entries(endpoint.urlParams).forEach(([, param]) => {
                const storedParam = this.findParameterByLocationAndName(nodeName, storedEndpoint.name, types_1.ParameterLocation.UrlPath, param.name);
                if (storedParam) {
                    this.addUrlParam(nodeName, storedEndpoint.name, param);
                }
            });
        }
        if (endpoint.hasOwnProperty('query')) {
            Object.entries(endpoint.query).forEach(([, param]) => {
                const storedParam = this.findParameterByLocationAndName(nodeName, storedEndpoint.name, types_1.ParameterLocation.Query, param.name);
                if (storedParam) {
                    this.addQueryParam(nodeName, storedEndpoint.name, param);
                }
            });
        }
        if (endpoint.hasOwnProperty('body')) {
            Object.entries(endpoint.body).forEach(([, param]) => {
                const storedParam = this.findParameterByLocationAndName(nodeName, storedEndpoint.name, types_1.ParameterLocation.Body, param.name);
                if (!storedParam) {
                    this.addBodyParam(nodeName, storedEndpoint.name, param);
                }
            });
        }
        if (endpoint.hasOwnProperty('response')) {
            endpoint.responses.forEach((response) => {
                const storedResponse = this.findResponseByStatus(nodeName, storedEndpoint.name, response.status);
                if (storedResponse) {
                    this.upsertResponse(nodeName, endpoint.name, response.status, response);
                }
            });
        }
    }
    addEndpointParam(nodeName, endpointName, param, location) {
        const endpoint = this.findOrCreateEndpointByName(nodeName, endpointName);
        if (location === types_1.ParameterLocation.UrlPath) {
            endpoint.urlParams.push(param);
        }
        else if (location === types_1.ParameterLocation.Query) {
            endpoint.query.push(param);
        }
        else if (location === types_1.ParameterLocation.Body) {
            endpoint.body.push(param);
        }
    }
    createEndpointParam(nodeName, endpointName, name, type, required, location) {
        const param = {
            name,
            type,
            required
        };
        this.addEndpointParam(nodeName, endpointName, param, location);
        return param;
    }
    upsertEndpointParam(nodeName, endpointName, param, location) {
        const storedParam = this.findOrCreateParameterByLocationAndName(nodeName, endpointName, location, param.name);
        storedParam.name = param.name ? param.name : storedParam.name;
        storedParam.type = param.type ? param.type : storedParam.type;
        storedParam.required = typeof param.required === 'boolean' ? param.required : storedParam.required;
        storedParam.isArray = typeof param.isArray === 'boolean' ? param.isArray : storedParam.isArray;
    }
    addQueryParam(nodeName, endpointName, param) {
        param.required = typeof param.required === 'boolean' ? param.required : false;
        this.addEndpointParam(nodeName, endpointName, param, types_1.ParameterLocation.Query);
    }
    createQueryParam(nodeName, endpointName, name, type, required = false) {
        this.createEndpointParam(nodeName, endpointName, name, type, required, types_1.ParameterLocation.Query);
    }
    upsertQueryParam(nodeName, endpointName, param) {
        param.required = typeof param.required === 'boolean' ? param.required : false;
        this.upsertEndpointParam(nodeName, endpointName, param, types_1.ParameterLocation.Query);
    }
    addUrlParam(nodeName, endpointName, param) {
        param.required = true;
        this.addEndpointParam(nodeName, endpointName, param, types_1.ParameterLocation.UrlPath);
    }
    createUrlParam(nodeName, endpointName, name, type) {
        const required = true;
        this.createEndpointParam(nodeName, endpointName, name, type, required, types_1.ParameterLocation.UrlPath);
    }
    upsertUrlParam(nodeName, endpointName, param) {
        param.required = true;
        this.upsertEndpointParam(nodeName, endpointName, param, types_1.ParameterLocation.UrlPath);
    }
    setUrlParamFromFullPath(nodeName, endpointName) {
        const nodeFullPath = this.getNodeFullPath(nodeName);
        const endpoint = this.findOrCreateEndpointByName(nodeName, endpointName);
        const fullEndpointPath = helpers_1.urlResolve(nodeFullPath, endpoint.path);
        const urlParams = helpers_1.pullOutParamsFromUrl(fullEndpointPath);
        this.upsertEndpoint(nodeName, endpointName, { name: endpointName, urlParams });
        return;
    }
    addBodyParam(nodeName, endpointName, param) {
        param.required = typeof param.required === 'boolean' ? param.required : false;
        this.addEndpointParam(nodeName, endpointName, param, types_1.ParameterLocation.Body);
        this.setBodyTypeIfEmpty(nodeName, endpointName, types_1.Types.Object);
    }
    createBodyParam(nodeName, endpointName, name, type, required = false) {
        this.createEndpointParam(nodeName, endpointName, name, type, required, types_1.ParameterLocation.Body);
        this.setBodyTypeIfEmpty(nodeName, endpointName, types_1.Types.Object);
    }
    upsertBodyParam(nodeName, endpointName, param) {
        param.required = typeof param.required === 'boolean' ? param.required : false;
        this.upsertEndpointParam(nodeName, endpointName, param, types_1.ParameterLocation.Body);
        this.setBodyTypeIfEmpty(nodeName, endpointName, types_1.Types.Object);
    }
    setBodyType(nodeName, endpointName, type) {
        const endpoint = this.findOrCreateEndpointByName(nodeName, endpointName);
        endpoint.bodyType = type;
    }
    markBodyAsArray(nodeName, endpointName) {
        const endpoint = this.findOrCreateEndpointByName(nodeName, endpointName);
        endpoint.bodyIsArray = true;
    }
    setBodyTypeIfEmpty(nodeName, endpointName, type) {
        const endpoint = this.findOrCreateEndpointByName(nodeName, endpointName);
        if (!endpoint.bodyType) {
            this.setBodyType(nodeName, endpointName, type);
        }
    }
    addResponse(nodeName, endpointName, response) {
        const endpoint = this.findOrCreateEndpointByName(nodeName, endpointName);
        endpoint.responses.push(response);
    }
    createResponse(nodeName, endpointName, status, responseType = types_1.Types.String, isArray = false, description = 'OK') {
        const response = {
            status,
            responseType,
            isArray,
            description
        };
        this.addResponse(nodeName, endpointName, response);
        return response;
    }
    upsertResponse(nodeName, endpointName, status, response) {
        const storedResponse = this.findOrCreateResponseByStatus(nodeName, endpointName, status);
        storedResponse.status = response.status ? response.status : storedResponse.status;
        storedResponse.description = response.description ? response.description : storedResponse.description;
        storedResponse.responseType = response.responseType ? response.responseType : storedResponse.responseType;
        storedResponse.isArray = response.isArray ? response.isArray : storedResponse.isArray;
        return;
    }
    addResponseType(type) {
        this._types.push(type);
    }
    createResponseType(name, typeScheme, type) {
        const scheme = Object
            .entries(typeScheme)
            .reduce((params, [field, type]) => lodash_1.concat(params, helpers_1.generateParamMeta(field, type)), []);
        const responseType = {
            name,
            scheme,
            type
        };
        this.addResponseType(responseType);
        return responseType;
    }
    findNodeByName(name) {
        return this._nodes.find((node) => node.name === name) || null;
    }
    findOrCreateNodeByName(name) {
        const node = this.findNodeByName(name);
        if (node) {
            return node;
        }
        return this.createNode(name, null);
    }
    findEndpointByName(nodeName, endpointName) {
        const node = this.findNodeByName(nodeName);
        if (!node) {
            return null;
        }
        return node.endpoints.find((endpoint) => endpoint.name === endpointName) || null;
    }
    findOrCreateEndpointByName(nodeName, endpointName) {
        const endpoint = this.findEndpointByName(nodeName, endpointName);
        if (endpoint) {
            return endpoint;
        }
        const node = this.findOrCreateNodeByName(nodeName);
        return this.createEndpoint(node.name, endpointName, null, null);
    }
    findResponseByStatus(nodeName, endpointName, status) {
        const endpoint = this.findEndpointByName(nodeName, endpointName);
        if (!endpoint) {
            return null;
        }
        return endpoint.responses.find((response) => response.status === status) || null;
    }
    findOrCreateResponseByStatus(nodeName, endpointName, status) {
        const response = this.findResponseByStatus(nodeName, endpointName, status);
        if (response) {
            return response;
        }
        const node = this.findOrCreateNodeByName(nodeName);
        const endpoint = this.findOrCreateEndpointByName(nodeName, endpointName);
        return this.createResponse(node.name, endpoint.name, status);
    }
    findResponseType(name) {
        return this._types.find((type) => type.name === name) || null;
    }
    findParameterByLocationAndName(nodeName, endpointName, location, name) {
        const endpoint = this.findEndpointByName(nodeName, endpointName);
        if (!endpoint) {
            return null;
        }
        let param;
        if (location === types_1.ParameterLocation.Body) {
            param = endpoint.body.find((param) => param.name === name);
        }
        else if (location === types_1.ParameterLocation.Query) {
            param = endpoint.query.find((param) => param.name === name);
        }
        else if (location === types_1.ParameterLocation.UrlPath) {
            param = endpoint.urlParams.find((param) => param.name === name);
        }
        return param || null;
    }
    findOrCreateParameterByLocationAndName(nodeName, endpointName, location, name) {
        let param = this.findParameterByLocationAndName(nodeName, endpointName, location, name);
        if (param) {
            return param;
        }
        const endpoint = this.findOrCreateEndpointByName(nodeName, endpointName);
        param = helpers_1.generateParamMeta(name);
        if (location === types_1.ParameterLocation.Body) {
            endpoint.body.push(param);
        }
        else if (location === types_1.ParameterLocation.Query) {
            endpoint.query.push(param);
        }
        else if (location === types_1.ParameterLocation.UrlPath) {
            endpoint.urlParams.push(param);
        }
        return param;
    }
    getNodeFullPath(nodeName) {
        const node = this.findNodeByName(nodeName);
        if (node.relatedTo) {
            const partOfPath = [this.getNodeFullPath(node.relatedTo), node.combiner, node.path]
                .filter((part) => part !== null);
            return helpers_1.urlResolve(...partOfPath);
        }
        return `/${node.path}`;
    }
}
exports.NodeStorage = NodeStorage;
//# sourceMappingURL=index.js.map