var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = require("../src/decorators");
const storage_1 = require("../src/storage");
const sw_generator_1 = require("../src/sw.generator");
const lodash_1 = require("lodash");
describe('AIO test', () => {
    const ownerBaseUrl = 'owners';
    const dogBaseUrl = 'dogs';
    let Owner = class Owner {
        getOwners() {
        }
        getOwnerById() {
        }
    };
    __decorate([
        decorators_1.Get('/'),
        decorators_1.Response(200, '#/Owner[]'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Owner.prototype, "getOwners", null);
    __decorate([
        decorators_1.Get('/:id'),
        decorators_1.Param('id', 'number'),
        decorators_1.Response(200, '#/Owner'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Owner.prototype, "getOwnerById", null);
    Owner = __decorate([
        decorators_1.BaseUrl(ownerBaseUrl)
    ], Owner);
    let Dog = class Dog {
        getDogs() {
        }
        getDogById() {
        }
        createDog() {
        }
        updateDog() {
        }
        updateDogOwner() {
        }
        deleteDog() {
        }
    };
    __decorate([
        decorators_1.Get('/'),
        decorators_1.Query('token', 'string'),
        decorators_1.Response(200, '#/Dog', true),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Dog.prototype, "getDogs", null);
    __decorate([
        decorators_1.Get('/:id/'),
        decorators_1.Param('id', 'number'),
        decorators_1.Query('token', 'string'),
        decorators_1.Response(200, '#/Dog'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Dog.prototype, "getDogById", null);
    __decorate([
        decorators_1.Post('/:id/'),
        decorators_1.Query('token', 'string'),
        decorators_1.Param('id', 'number'),
        decorators_1.Body({ name: 'string', owner: 'string' }),
        decorators_1.Response(201, '#/Dog'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Dog.prototype, "createDog", null);
    __decorate([
        decorators_1.Put(':id'),
        decorators_1.Query('token', 'string'),
        decorators_1.Param('id', 'number'),
        decorators_1.Body({ name: 'string', owner: 'string' }),
        decorators_1.Response(204, '#/Dog'),
        decorators_1.Response(403, 'string', false, 'FORBIDDEN'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Dog.prototype, "updateDog", null);
    __decorate([
        decorators_1.Patch('/:id/owner'),
        decorators_1.Query('token', 'string'),
        decorators_1.Param('id', 'number'),
        decorators_1.Body('owner', 'string'),
        decorators_1.Response(204),
        decorators_1.Response(403, 'string', false, 'FORBIDDEN'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Dog.prototype, "updateDogOwner", null);
    __decorate([
        decorators_1.Delete('/:id/'),
        decorators_1.Query('token', 'string'),
        decorators_1.Param('id', 'number'),
        decorators_1.Response(204),
        decorators_1.Response(403, 'string', false, 'FORBIDDEN'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Dog.prototype, "deleteDog", null);
    Dog = __decorate([
        decorators_1.BaseUrl(dogBaseUrl, Owner, '/:ownerId/')
    ], Dog);
    function checkParams(params) {
        params.forEach(({ type, name }) => {
            expect(typeof type).toEqual('string');
            expect(typeof name).toEqual('string');
        });
    }
    function checkResponse(res) {
        expect(typeof res.description).toEqual('string');
        expect(typeof res.responseType).toEqual('string');
        expect(typeof res.status).toEqual('number');
    }
    beforeAll(() => {
        const dogScheme = {
            name: 'string',
            owner: 'string',
            id: 'number'
        };
        decorators_1.addResponseType('Dog', dogScheme);
        const ownerScheme = {
            name: 'string',
            id: 'number',
            dog: '#/Dog'
        };
        decorators_1.addResponseType('Owner', ownerScheme);
    });
    it('Owner\'s node should be ok', () => {
        const storage = storage_1.NodeStorage.getInstance();
        const ownerNode = storage.findNodeByName(Owner.name);
        expect(ownerNode).not.toBeNull();
        expect(ownerNode.name).toEqual(Owner.name);
        expect(ownerNode.path).toEqual(ownerBaseUrl);
        expect(ownerNode.relatedTo).toBeNull();
        expect(ownerNode.endpoints.length).toEqual(2);
        ownerNode.endpoints.forEach((endpoint) => {
            expect(typeof endpoint.description).toEqual('string');
            expect(typeof endpoint.method).toEqual('string');
            expect(typeof endpoint.name).toEqual('string');
            expect(typeof endpoint.path).toEqual('string');
            checkParams(endpoint.body);
            checkParams(endpoint.query);
            checkParams(endpoint.urlParams);
            endpoint.responses.forEach((res) => checkResponse(res));
        });
    });
    it('Dog\'s node should be ok', () => {
        const storage = storage_1.NodeStorage.getInstance();
        const dogNode = storage.findNodeByName(Dog.name);
        expect(dogNode).not.toBeNull();
        expect(dogNode.name).toEqual(Dog.name);
        expect(dogNode.path).toEqual(dogBaseUrl);
        expect(dogNode.relatedTo).toEqual(Owner.name);
        expect(dogNode.endpoints.length).toEqual(6);
        dogNode.endpoints.forEach((endpoint) => {
            expect(typeof endpoint.description).toEqual('string');
            expect(typeof endpoint.method).toEqual('string');
            expect(typeof endpoint.name).toEqual('string');
            expect(typeof endpoint.path).toEqual('string');
            checkParams(endpoint.body);
            checkParams(endpoint.query);
            checkParams(endpoint.urlParams);
            endpoint.responses.forEach((res) => checkResponse(res));
        });
    });
    it('`updateDogEndpoint` endpoint should be ok', () => {
        const storage = storage_1.NodeStorage.getInstance();
        const updateDogEndpoint = storage.findEndpointByName(Dog.name, new Dog().updateDog.name);
        expect(updateDogEndpoint.description).toEqual('');
        expect(updateDogEndpoint.method).toEqual('put');
        expect(updateDogEndpoint.name).toEqual(new Dog().updateDog.name);
        expect(updateDogEndpoint.path).toEqual(':id');
        expect(updateDogEndpoint.body).toEqual([
            {
                name: 'name',
                required: false,
                type: 'string',
                isArray: false
            },
            {
                name: 'owner',
                required: false,
                type: 'string',
                isArray: false
            }
        ]);
        expect(updateDogEndpoint.query).toEqual([
            {
                name: 'token',
                required: false,
                type: 'string',
                isArray: false
            }
        ]);
        expect(updateDogEndpoint.urlParams).toEqual([
            {
                name: 'id',
                required: true,
                type: 'number',
                isArray: false
            }
        ]);
        const [okResponse, forbiddenResponse] = lodash_1.sortBy(updateDogEndpoint.responses, 'status');
        expect(okResponse.status).toEqual(204);
        expect(okResponse.description).toEqual('OK');
        expect(okResponse.responseType).toEqual('#/Dog');
        expect(forbiddenResponse.status).toEqual(403);
        expect(forbiddenResponse.description).toEqual('FORBIDDEN');
        expect(forbiddenResponse.responseType).toEqual('string');
    });
    it('response type `Dog` should be ok', () => {
        const storage = storage_1.NodeStorage.getInstance();
        const dogType = storage.findResponseType('Dog');
        expect(dogType.name).toEqual('Dog');
        expect(lodash_1.sortBy(dogType.scheme, ['name'])).toEqual(lodash_1.sortBy([
            {
                name: 'name',
                required: false,
                type: 'string',
                isArray: false
            },
            {
                name: 'id',
                required: false,
                type: 'number',
                isArray: false
            },
            {
                name: 'owner',
                required: false,
                type: 'string',
                isArray: false
            }
        ], ['name']));
    });
    it('should create sw json', () => {
        const swJson = sw_generator_1.generateSwaggerJson();
        expect(swJson).toBeTruthy();
    });
    it('should create sw yaml', () => {
        const swYaml = sw_generator_1.generateSwaggerYaml();
        expect(typeof swYaml).toEqual('string');
    });
});
//# sourceMappingURL=example.of.usage.spec.js.map